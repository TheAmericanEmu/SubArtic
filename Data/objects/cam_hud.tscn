[gd_scene format=3 uid="uid://7d4nq76w2sg4"]

[ext_resource type="FontFile" uid="uid://dj0tnf36fwsu8" path="res://Data/Fonts/HomeVideo-BLG6G.ttf" id="1_2nky1"]
[ext_resource type="Script" uid="uid://0bh58aot7sfj" path="res://src/cam_hud.gd" id="1_4namc"]
[ext_resource type="Texture2D" uid="uid://btx2nf22lm1gx" path="res://Data/textures/d3jmbjq-9d52e89c-e6eb-40ab-9517-8754ba9a3bcc-ezgif.com-gif-to-sprite-converter.png" id="2_mirpg"]

[sub_resource type="LabelSettings" id="LabelSettings_mirpg"]
font = ExtResource("1_2nky1")
font_size = 32

[sub_resource type="Shader" id="Shader_4namc"]
code = "// CRT Shader for Godot Engine
// Simulates the look of old CRT displays with various customizable effects
shader_type canvas_item;

// Built-in texture for screen sampling
uniform sampler2D SCREEN_TEXTURE: hint_screen_texture;

// Base resolution for pixel-perfect effects (lower values = larger pixels)
uniform vec2 resolution = vec2(320.0, 180.0);

// ===== Effect Controls =====
// Each parameter has a sensible default and range hint for the Godot editor

// Scanline effect (dark lines between pixel rows)
uniform float scan_line_amount : hint_range(0.0, 1.0) = 1.0;
uniform float scan_line_strength : hint_range(-12.0, -1.0) = -8.0;

// Screen curvature/warp effect
uniform float warp_amount : hint_range(0.0, 5.0) = 0.1;

// Visual noise/interference
uniform float noise_amount : hint_range(0.0, 0.3) = 0.03;
uniform float interference_amount : hint_range(0.0, 1.0) = 0.2;

// Shadow mask/grille (simulates color phosphor patterns)
uniform float grille_amount : hint_range(0.0, 1.0) = 0.1;
uniform float grille_size : hint_range(1.0, 5.0) = 1.0;

// Vignette (darkening at screen edges)
uniform float vignette_amount : hint_range(0.0, 2.0) = 0.6;
uniform float vignette_intensity : hint_range(0.0, 1.0) = 0.4;

// Chromatic aberration (color separation)
uniform float aberation_amount : hint_range(0.0, 1.0) = 0.5;

// Rolling line effect (simulates VHS/analog interference)
uniform float roll_line_amount : hint_range(0.0, 1.0) = 0.3;
uniform float roll_speed : hint_range(-8.0, 8.0) = 1.0;

// Pixel sharpness/softness
uniform float pixel_strength : hint_range(-4.0, 0.0) = -2.0;

// ===== Utility Functions =====

/**
 * Generates a pseudo-random float between 0 and 1 based on input coordinates
 */
float random(vec2 uv) {
    return fract(cos(uv.x * 83.4827 + uv.y * 92.2842) * 43758.5453123);
}

/**
 * Samples a pixel from the screen texture with optional offset and noise
 * Handles edge cases and applies noise if enabled
 */
vec3 fetch_pixel(vec2 uv, vec2 off) {
    // Calculate pixel position with offset and snap to pixel grid
    vec2 pos = floor(uv * resolution + off) / resolution + vec2(0.5) / resolution;

    // Apply noise if enabled
    float noise = 0.0;
    if (noise_amount > 0.0) {
        noise = random(pos + fract(TIME)) * noise_amount;
    }

    // Clamp to screen bounds (return black if outside)
    if (max(abs(pos.x - 0.5), abs(pos.y - 0.5)) > 0.5) {
        return vec3(0.0);
    }

    // Sample the texture with mipmap bias for sharper pixels
    return texture(SCREEN_TEXTURE, pos, -16.0).rgb + noise;
}

// ===== Pixel and Scanline Processing =====

/**
 * Calculates distance from current pixel to nearest texel center
 * Used for sub-pixel filtering and anti-aliasing
 */
vec2 Dist(vec2 pos) { 
    pos = pos * resolution;
    return -((pos - floor(pos)) - vec2(0.5));
}
    
/**
 * 1D Gaussian function for smooth filtering
 */
float Gaus(float pos, float scale) { 
    return exp2(scale * pos * pos); 
}

/**
 * 3-tap Gaussian filter along horizontal line
 * Creates smooth horizontal blending between pixels
 */
vec3 Horz3(vec2 pos, float off) {
    // Sample three horizontally adjacent pixels
    vec3 b = fetch_pixel(pos, vec2(-1.0, off));
    vec3 c = fetch_pixel(pos, vec2( 0.0, off));
    vec3 d = fetch_pixel(pos, vec2( 1.0, off));
    
    // Calculate weights based on distance from pixel center
    float dst = Dist(pos).x;
    float wb = Gaus(dst - 1.0, pixel_strength);
    float wc = Gaus(dst + 0.0, pixel_strength);
    float wd = Gaus(dst + 1.0, pixel_strength);
    
    // Return weighted average of samples
    return (b * wb + c * wc + d * wd) / (wb + wc + wd);
}

/**
 * Calculates scanline weight for a given position and offset
 * Creates the dark lines between pixel rows
 */
float Scan(vec2 pos, float off) {
    float dst = Dist(pos).y;
    return Gaus(dst + off, scan_line_strength);
}

/**
 * Applies scanline effect by blending multiple horizontal samples
 * Combines three scanlines with gaussian weights for smooth transitions
 */
vec3 Tri(vec2 pos) {
    vec3 clr = fetch_pixel(pos, vec2(0.0));
    
    if (scan_line_amount > 0.0) {
        // Sample three vertically adjacent scanlines
        vec3 a = Horz3(pos, -1.0);
        vec3 b = Horz3(pos,  0.0);
        vec3 c = Horz3(pos,  1.0);

        // Calculate scanline weights
        float wa = Scan(pos, -1.0);
        float wb = Scan(pos,  0.0);
        float wc = Scan(pos,  1.0);

        // Blend between original and scanline-affected color
        vec3 scanlines = a * wa + b * wb + c * wc;
        clr = mix(clr, scanlines, scan_line_amount);
    }
    
    return clr;
}

// ===== Screen Warping and Distortion Effects =====

/**
 * Applies a spherize/bulge distortion to simulate CRT screen curvature
 * Warps UV coordinates more severely towards screen edges
 */
vec2 warp(vec2 uv) {
    // Calculate distance from center and apply non-linear warping
    vec2 delta = uv - 0.5;
    float delta2 = dot(delta.xy, delta.xy);
    float delta4 = delta2 * delta2;
    float delta_offset = delta4 * warp_amount;
    
    // Apply warping and normalize back to 0-1 range
    vec2 warped = uv + delta * delta_offset;
    return (warped - 0.5) / mix(1.0, 1.2, warp_amount/5.0) + 0.5;
}

/**
 * Applies vignette effect (darkening at screen edges)
 * Uses a smooth falloff based on distance from center
 */
float vignette(vec2 uv) {
    // Create circular falloff from center
    uv *= 1.0 - uv.xy;
    float vignette = uv.x * uv.y * 15.0;
    
    // Apply intensity controls
    return pow(vignette, vignette_intensity * vignette_amount);
}

/**
 * Simulates a shadow mask/grille pattern like those found in CRT displays
 * Creates color separation similar to real phosphor patterns
 */
vec3 grille(vec2 uv) {
    float unit = PI / 3.0;
    float scale = 2.0 * unit / grille_size;
    
    // Create offset color patterns for RGB channels
    float r = smoothstep(0.5, 0.8, cos(uv.x * scale - unit));
    float g = smoothstep(0.5, 0.8, cos(uv.x * scale + unit));
    float b = smoothstep(0.5, 0.8, cos(uv.x * scale + 3.0 * unit));
    
    // Blend between original color and grille pattern
    return mix(vec3(1.0), vec3(r, g, b), grille_amount);
}

/**
 * Creates rolling horizontal interference lines
 * Simulates analog signal interference or VHS artifacts
 */
float roll_line(vec2 uv) {
    // Create complex wave pattern that moves with time
    float x = uv.y * 3.0 - TIME * roll_speed;
    float f = cos(x) * cos(x * 2.35 + 1.1) * cos(x * 4.45 + 2.3);
    
    // Threshold and smooth the wave to create distinct lines
    float roll_line = smoothstep(0.5, 0.9, f);
    return roll_line * roll_line_amount;
}

// ===== Main Shader Function =====

void fragment() {
    // Get screen coordinates and apply screen warping
    vec2 pix = FRAGCOORD.xy;
    vec2 pos = warp(SCREEN_UV);
    
    // Generate rolling interference lines if enabled
    float line = 0.0;
    if (roll_line_amount > 0.0) {
        line = roll_line(pos);
    }

    // Apply horizontal interference/jitter
    vec2 sq_pix = floor(pos * resolution) / resolution + vec2(0.5) / resolution;
    if (interference_amount + roll_line_amount > 0.0) {
        float interference = random(sq_pix.yy + fract(TIME));
        pos.x += (interference * (interference_amount + line * 6.0)) / resolution.x;
    }

    // Get base color with scanline processing
    vec3 clr = Tri(pos);
    
    // Apply chromatic aberration (color separation)
    if (aberation_amount > 0.0) {
        float chromatic = aberation_amount + line * 2.0;  // Enhanced by rolling lines
        vec2 chromatic_x = vec2(chromatic, 0.0) / resolution.x;
        vec2 chromatic_y = vec2(0.0, chromatic/2.0) / resolution.y;
        
        // Sample RGB channels with slight offsets
        float r = Tri(pos - chromatic_x).r;  // Red shifted left
        float g = Tri(pos + chromatic_y).g;  // Green shifted down
        float b = Tri(pos + chromatic_x).b;  // Blue shifted right
        clr = vec3(r, g, b);
    }
    
    // Apply shadow mask/grille effect
    if (grille_amount > 0.0) {
        clr *= grille(pix);
    }
    
    // Adjust overall brightness based on effects
    clr *= 1.0 + scan_line_amount * 0.6 + line * 3.0 + grille_amount * 2.0;
    
    // Apply vignette (darken edges)
    if (vignette_amount > 0.0) {
        clr *= vignette(pos);
    }
    
    // Output final color
    COLOR.rgb = clr;
    COLOR.a = 1.0;
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_bbreo"]
shader = SubResource("Shader_4namc")
shader_parameter/resolution = Vector2(320, 180)
shader_parameter/scan_line_amount = 1.0
shader_parameter/scan_line_strength = -6.9449997598875
shader_parameter/warp_amount = 0.1
shader_parameter/noise_amount = 0.03
shader_parameter/interference_amount = 0.2
shader_parameter/grille_amount = 0.1
shader_parameter/grille_size = 1.0
shader_parameter/vignette_amount = 0.6
shader_parameter/vignette_intensity = 0.4
shader_parameter/aberation_amount = 0.5
shader_parameter/roll_line_amount = 0.3
shader_parameter/roll_speed = 1.7720004641700005
shader_parameter/pixel_strength = -4.0

[sub_resource type="CanvasItemMaterial" id="CanvasItemMaterial_bbreo"]
light_mode = 1

[sub_resource type="AtlasTexture" id="AtlasTexture_x5lin"]
atlas = ExtResource("2_mirpg")
region = Rect2(0, 0, 533, 300)

[sub_resource type="AtlasTexture" id="AtlasTexture_hbcig"]
atlas = ExtResource("2_mirpg")
region = Rect2(533, 0, 533, 300)

[sub_resource type="AtlasTexture" id="AtlasTexture_jk2ll"]
atlas = ExtResource("2_mirpg")
region = Rect2(1066, 0, 533, 300)

[sub_resource type="AtlasTexture" id="AtlasTexture_f3ox7"]
atlas = ExtResource("2_mirpg")
region = Rect2(1599, 0, 533, 300)

[sub_resource type="AtlasTexture" id="AtlasTexture_re55c"]
atlas = ExtResource("2_mirpg")
region = Rect2(2132, 0, 533, 300)

[sub_resource type="SpriteFrames" id="SpriteFrames_4namc"]
animations = [{
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_x5lin")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_hbcig")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_jk2ll")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_f3ox7")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_re55c")
}],
"loop": true,
"name": &"default",
"speed": 24.0
}]

[node name="CamHud" type="Control" unique_id=1131783337]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_4namc")

[node name="StaticText1" type="Label" parent="." unique_id=1941536605]
layout_mode = 1
anchors_preset = 2
anchor_top = 1.0
anchor_bottom = 1.0
offset_top = -23.0
offset_right = 40.0
grow_vertical = 0
text = "Cam Feed 1"
label_settings = SubResource("LabelSettings_mirpg")

[node name="Stats" type="Label" parent="." unique_id=1913446081]
layout_mode = 1
anchors_preset = 3
anchor_left = 1.0
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = -192.0
offset_top = -30.0
grow_horizontal = 0
grow_vertical = 0
text = "Depth:"
label_settings = SubResource("LabelSettings_mirpg")
horizontal_alignment = 2

[node name="Time" type="Label" parent="." unique_id=1656794724]
layout_mode = 1
anchors_preset = 3
anchor_left = 1.0
anchor_top = 1.0
anchor_right = 1.0
anchor_bottom = 1.0
offset_left = -1152.0
offset_top = -648.0
offset_right = -960.0
offset_bottom = -618.0
grow_horizontal = 0
grow_vertical = 0
label_settings = SubResource("LabelSettings_mirpg")

[node name="Panel" type="ColorRect" parent="." unique_id=161063965]
material = SubResource("ShaderMaterial_bbreo")
layout_mode = 0
offset_left = -66.99994
offset_top = -84.0
offset_right = 1290.0
offset_bottom = 707.0

[node name="Static" type="AnimatedSprite2D" parent="." unique_id=1367941470]
self_modulate = Color(1, 1, 1, 0.11764706)
material = SubResource("CanvasItemMaterial_bbreo")
position = Vector2(591.00006, 314.00003)
scale = Vector2(2.5, 2.5)
sprite_frames = SubResource("SpriteFrames_4namc")
autoplay = "default"
frame_progress = 0.22913174
